#' Extracting data from csv files produced by Perkin Elmer Elan ICP-MS.
#'
#' Extracts 208Pb/207Pb, 206Pb/207Pb, 208Pb/206Pb and 207Pb/206Pb ratio data from the
#' raw .csv file produced by the instrument Perkin Elmer Elan ICP-MS working in isotope
#' ratio mode.
#'
#' @import data.table
#'
#' @param filename A dataset saved in csv format with "," as field separator and "." as
#'     decimal separator. Such dataset is derived from .rep files provided by the
#'     instrument by opening it with spreadsheet editor and saving it as .csv file using
#'     a local setting = EN-US or equivalent.
#'     The .csv file must contain the sample name, a summary of the measuring conditions,
#'     the raw intensities for each monitored isotopes and a final summary with average
#'     signal intensities and isotope ratios. These pieces of information are repeated
#'     for each sample. Bracketing standards are assumed to be NIST SRM 981 and should
#'     be labelled as \code{SRM}. QC samples are assumed to be BCR CRM 482 and should be
#'     labbelled as \code{CRM}.
#'
#' @param report A string referring to the type of report generated by the instrument
#'     accepted values are either \code{"short"} or \code{"long"}.
#'     \describe{
#'     \item{\bold{Short}} {reports have only information about the sample ID,
#'     sample time, a summary with average intensities and then the intensity values
#'     for each replicate.}
#'     \item{\bold{Long}} { reports contain also information about the measurement conditions
#'      and the summary section is at the end of the intensity values for each replicates.
#'      They are usually produced when working in isotope ratio mode.}
#'     }
#'
#' @return A data.table containing raw intensities and raw Pb isotope ratios
#'     for each sample. Provided isotope ratios are 208Pb/207Pb, 206Pb/207Pb, 208Pb/206Pb
#'     and 207Pb/206Pb.
#'     Note that these ratios have still to be inspected for outliers, summarised and
#'     corrected for mass bias.
#'
#' @examples
#' file.short <- system.file("extdata", "sednya_2015.csv", package = "pbratios")
#' sednya.2015 <- extract.data(file.short, report = "short")
#'
#' file.long <- system.file("extdata", "spmnya_2012.csv", package = "pbratios")
#' spmnya.2012 <- extract.data(file.long, report = "long")
#'
#' @export
#'
extract.data <- function(filename, report = c("short", "long")) {
  report <- match.arg(report)

  if (report != "short" & report != "long") {
    stop('Error: report must be either equal to "short" or "long".')
  }

  # Loading the file
  data <- fread(filename, header = FALSE, na.strings = "")

  # Extracting the sample name
  sampleid <- data[grepl("Sample ID", V1), V2]

  # Fixing names for SRMs and CRMs
  srm_id <- grepl("SRM", sampleid) & !grepl("test", sampleid)
  crm_id <- grepl("CRM", sampleid)

  sampleid[srm_id] <- paste("SRM981", 1:length(sampleid[srm_id]), sep = "_")
  sampleid[crm_id] <- paste("CRM482", 1:length(sampleid[crm_id]), sep = "_")

  if (report == "short"){

    # Row number for "Replicates" and "Sample ID"
    rep.row <- data[, row.id := 1:.N][grepl("Replicates", V1), row.id]
    sample.row <- data[grepl("Sample ID", V1), row.id][-1]
    sample.row[length(sample.row) + 1] <- data[.N, row.id + 1]
    # Row numbers with data for each sample
    n.row <- sample.row - rep.row - 1

    # Select row with data
    data <- data[as.vector(mapply(seq, rep.row + 1, sample.row - 1)), ][,
    # Assigning sample names
                      sample := rep(sampleid, n.row)][
    # Remove rows with "Analyte"
                      -grep("Analyte", V1)]

    data <- setnames(
      data,
      old = c("V1", "V2", "V3"),
      new = c("element", "isotope", "intensity")
    )
  }

  if (report == "long"){

    # Row number for "Replicates" and "Summary"
    rep.row <- data[, row.id := 1:.N][grepl("^Replicates$", V1), row.id]
    summary.row <- data[grepl("^Summary$", V1), row.id]

    # Row numbers with data for each sample
    n.row <- summary.row - rep.row - 1


    # Select row with data
    data <- data[as.vector(mapply(seq, rep.row + 1, summary.row - 1)), ][,
    # Assigning sample names
                sample := rep(sampleid, n.row)][
    # Remove rows with "Replicate"
                -grep("Replicate", V1)][
    # Remove rows with "Analyte"
                -grep("Analyte", V2)]

  ## Rename the columns
  data <- setnames(
          data,
          old = c("V2", "V3", "V4"),
          new = c("element", "isotope", "intensity")
  )

  }

  # Merge columns "element" and "isotope" to the new column "nuclide"
  data <- data[, nuclide := paste0(element, isotope)][,
               .(sample, nuclide, intensity)]

  ## Assigning each column to its right class
  data.factor <- c("sample", "nuclide")
  data[, (data.factor) := lapply(.SD, as.factor),
       .SDcols = data.factor][, intensity := as.double(intensity)] # S values <- NAs

  # Put the dataset in wide format
  lvls <- as.character(unique(data$sample))
  data.clean <- dcast(data[, id := 1:.N, by = .(sample, nuclide)],
                      id + sample ~ nuclide, value.var = 'intensity')[,
                      sample := factor(sample, levels = lvls)][order(sample)]

  # Calculate the raw ratios
  data.clean[, c("Pb208207",
                 "Pb206207",
                 "Pb208206",
                 "Pb207206") :=
               .(Pb208 / Pb207,
                 Pb206 / Pb207,
                 Pb208 / Pb206,
                 Pb207 / Pb206)][, -"id", with = FALSE]
}
# End of function
